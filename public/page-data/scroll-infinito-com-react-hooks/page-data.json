{"componentChunkName":"component---src-templates-post-js","path":"/scroll-infinito-com-react-hooks/","result":{"data":{"wordpressPost":{"id":"6154dfae-ca45-594a-a89a-d6cb8c08aab2","title":"Scroll Infinito com React Hooks üöÄ","content":"\n<p>Scroll infinito n√£o √© algo comum de se ver mas pode ser muito √∫til e pr√°tico na hora de exibir uma lista sem ter que usar uma pagina√ß√£o e precisar de uma maior intera√ß√£o do usu√°rio.</p>\n\n\n\n<p>Eu j√° precisei fazer em um projeto h√° um tempo e utilizei essa lib que funcionou muito bem, por√©m, recentemente eu decidi reescrever esse projeto e tentar criar o scroll infinito com react hooks e a IntersectionObserver API, sem nenhuma lib externa, e funcionou muito bem. Por isso gostaria de compartilhar o resultado com voc√™s.</p>\n\n\n\n<p>Ele ser√° bem simples, usarei um componente com um <em>state</em> pra indicar o estado do loading na p√°gina, outro para armazenar os dados da nossa listagem e a refer√™ncia de um componente. Ocultarei o CSS por ser irrelevante mas voc√™ pode ver o resultado final clicando aqui.</p>\n\n\n\n<h3>Criando nosso componente</h3>\n\n\n\n<p>Primeiro vamos criar nosso componente que exibir√° os dados.</p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-jsx\">import React, { useState, useEffect, useRef } from \"react\";\n\nconst List = () =&amp;gt; {\n  const lastRef = useRef(null); // highlight-line\n  const [isLoading, setIsLoading] = useState(false);\n  const [todos, setTodos] = useState({\n    itens: [],\n    page: 0,\n    totalPages: 1,\n  });\n\n  return (\n    { /* highlight-range{1,4} */ }\n    &amp;lt;div&amp;gt;\n      &amp;lt;h2&amp;gt;Lorem ipsum's list&amp;lt;/h2&amp;gt;\n      {todos.itens.map(({ title }, index) =&amp;gt; {\n        return (\n          &amp;lt;div key={index}&amp;gt;\n            &amp;lt;p&amp;gt;{title}&amp;lt;/p&amp;gt;\n          &amp;lt;/div&amp;gt;\n        );\n      })}\n      {!!todos.itens.length &amp;amp;&amp;amp; &amp;lt;div ref={lastRef} /&amp;gt;}\n      {isLoading &amp;amp;&amp;amp; &amp;lt;p&amp;gt;Loading...&amp;lt;/p&amp;gt;}\n    &amp;lt;/div&amp;gt;\n  );\n};\n\nexport default List;\n</code></pre>\n\n\n\n<h3>Buscando dados da API</h3>\n\n\n\n<p>Tamb√©m precisamos de um m√©todo que fa√ßa a requisi√ß√£o HTTP buscando os dados de alguma API. Eu criei uma fun√ß√£o chamada <em>fetchTodos</em> que recebe o n√∫mero da p√°gina que quero buscar como par√¢metro. Pra esse exemplo eu mockei o retorno dessa fun√ß√£o, n√£o irei compartilhar o c√≥digo aqui pois √© pra um caso muito espec√≠fico, se quiser voc√™ pode ver o c√≥digo que eu fiz clicando aqui, o mais importante √© que voc√™ tenha uma API que retorno no m√≠nimo esse formato de dados:</p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-javascript\">{\n  itens: [{...}],\n  totalPages: X,\n  page: X,\n}</code></pre>\n\n\n\n<h3>Custom Hook useIsElementVisible</h3>\n\n\n\n<p>Agora iremos criar nosso custom hook que indicar√° se o elemento est√° vis√≠vel na tela, usando a API IntersectionObserver pra isso, que √© nativa dos navegadores.</p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-javascript\">import { useEffect, useState } from \"react\";\n\nexport default (el) => {\n  const [isVisible, setIsVisible] = useState(false); //highlight-line\n  const callback = ([entry]) => {\n    setIsVisible(entry.isIntersecting);\n  };\n\n  useEffect(() => {\n    const watch = new IntersectionObserver(callback);\n    if (el) {\n      watch.observe(el);\n      return () => watch.unobserve(el);\n    }\n  }, [el]);\n\n  return isVisible &amp;&amp; !!el;\n};\n</code></pre>\n\n\n\n<p>Nosso objetivo √© passar a refer√™ncia de um elemento em baixo da lista e verificar se ele est√° vis√≠vel na tela ou n√£o. Se sim, disparamos a fun√ß√£o pra buscar mais itens.</p>\n\n\n\n<h3>Atualizando nosso componente</h3>\n\n\n\n<p>Tudo pronto, agora vamos criar nosso m√©todo pra buscar os dados. Tamb√©m usaremos o hook useEffect duas vezes; para disparar a fun√ß√£o no carregamento da p√°gina e quando o elemento a baixo da lista estiver vis√≠vel.</p>\n\n\n\n<pre class=\"wp-block-prismatic-blocks\"><code class=\"language-javascript\">const isLastVisible = useIsElementVisible(lastRef.current);\n\nuseEffect(() => {\n  // Fetch no mount da p√°gina.\n  getMoreTodos(todos.page + 1);\n}, []);\n\nuseEffect(() => {\n  // Fetch ao chegar no final da lista.\n  if (isLastVisible) {\n    getMoreTodos(todos.page + 1);\n  }\n}, [isLastVisible]);\n\nconst getMoreTodos = async (page) => {\n  try {\n    setIsLoading(true);\n    const newTodos = await fetchTodos(page);\n    setTodos((prev) => ({\n      ...newTodos,\n      itens: prev.itens.concat(newTodos.itens),\n    }));\n    setIsLoading(false);\n  } catch (err) {}\n};</code></pre>\n\n\n\n<h3>Conclus√£o</h3>\n\n\n\n<p>E est√° pronto nosso componente com scroll infinito. Eu apenas implementei a listagem e loading dos dados nesse exemplo, fique a vontade de estiliza-los como preferir. No mundo real voc√™ tamb√©m deve tratar a excess√£o no catch do m√©todo <em>getMoreTodos</em> se a API retornar algum erro.</p>\n\n\n\n<p>Voc√™ pode ver o reposit√≥rio com todo o c√≥digo clicando aqui.</p>\n","excerpt":"<p>Scroll infinito n√£o √© algo comum de se ver mas pode ser muito √∫til e pr√°tico na hora de exibir uma lista sem ter que usar uma pagina√ß√£o e precisar de uma maior intera√ß√£o do usu√°rio. Eu j√° precisei fazer em um projeto h√° um tempo e utilizei essa lib que funcionou muito bem, por√©m, [&hellip;]</p>\n","date":"06-29-2020","featured_media":{"alt_text":"","caption":"","localFile":{"childImageSharp":{"original":{"width":715,"height":477,"src":"/static/infinite-scrolling-featured-50a3c71e6b414cafffc22e4254b9fd71.jpg"}}}},"acf":{"translation":"nada"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"6154dfae-ca45-594a-a89a-d6cb8c08aab2"}}}