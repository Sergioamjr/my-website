{"componentChunkName":"component---src-templates-post-en-js","path":"/posts_en/replacing-redux-to-react-hooks/","result":{"data":{"wordpressWpPostsEn":{"id":"9e0c43b8-c34b-5348-9a7b-e01b8f62d6b8","title":"Replacing Redux to React Hooks","content":"\n<p>In 2019 I was learning how to use React Hooks and decided to replace the state management from a simple application that I was building of Redux to React Hooks. I didn&#8217;t know how I would do that, however, in the end, it worked pretty well.</p>\n\n\n\n<p>I kept the concerns of reducer, actions, types, middleware, mapStateToProps and I wrote an article on Medium showing up how I had made. After I shared within the community, it was even published at React Brazil&#8217;s Oficial Account on Medium.</p>\n\n\n\n<p>I was really happy with the feedback but I felt I could refactor that code which I wrote one year ago and make it clean, organized, therefore, I ended up rewriting my code example and my article, that became this that you&#8217;re reading right now. </p>\n\n\n\n<p>I&#8217;m using the same example of a simple counter and authentication. In case you want, you can check the demo and the repository with the final code.</p>\n\n\n\n<p>Primeiro, vamos criar os estados do nosso contador e autenticação na nossa store e também seus reducers, types e actions. Eles seguem basicamente o mesmo modelo do Redux, estou apenas usando o padrão Ducks pra manter tudo o que é relacionado no mesmo arquivo.</p>\n\n\n\n<p>Você pode ler mais sobre esse padrão de organização nesse link.</p>\n\n\n\n<p>//src/store/reducers/auth.js<br>\nexport const authDefault = {<br>\n  auth: {<br>\n    isLogged: false,<br>\n    user: {}<br>\n  }<br>\n};</p>\n\n\n\n<p>export const LOGIN = &#8220;LOGIN&#8221;;<br>\nexport const LOGOUT = &#8220;LOGOUT&#8221;;</p>\n\n\n\n<p>const authReducer = (state = authDefault, action) =&gt; {<br>\n  switch (action.type) {<br>\n    case LOGIN:<br>\n      return {<br>\n        auth: {<br>\n          …state.auth,<br>\n          isLogged: true,<br>\n          user: action.payload<br>\n        }<br>\n      };<br>\n    case LOGOUT:<br>\n      return {<br>\n        auth: {<br>\n          …state.auth,<br>\n          isLogged: false,<br>\n          user: {}<br>\n        }<br>\n      };<br>\n    default:<br>\n      return state;<br>\n  }<br>\n};</p>\n\n\n\n<p>export const loginAction = user =&gt; {<br>\n  return {<br>\n    type: LOGIN,<br>\n    payload: user<br>\n  };<br>\n};</p>\n\n\n\n<p>export const logoutAction = () =&gt; {<br>\n  return {<br>\n    type: LOGOUT<br>\n  };<br>\n};</p>\n\n\n\n<p>export default authReducer;</p>\n\n\n\n<p>//src/store/reducers/counter.js<br>\nexport const counterDefault = {<br>\n  counter: 0<br>\n};</p>\n\n\n\n<p>export const INCREMENT = &#8220;INCREMENT&#8221;;<br>\nexport const DECREMENT = &#8220;DECREMENT&#8221;;<br>\nexport const RESET = &#8220;RESET&#8221;;</p>\n\n\n\n<p>const counterReducer = (state = counterDefault, action) =&gt; {<br>\n  switch (action.type) {<br>\n    case INCREMENT:<br>\n      return {<br>\n        …state,<br>\n        counter: state.counter + 1<br>\n      };<br>\n    case DECREMENT:<br>\n      return {<br>\n        …state,<br>\n        counter: state.counter &#8211; 1<br>\n      };<br>\n    case RESET:<br>\n      return {<br>\n        counter: 0<br>\n      };<br>\n    default:<br>\n      return state;<br>\n  }<br>\n};</p>\n\n\n\n<p>export const incrementAction = () =&gt; {<br>\n  return {<br>\n    type: INCREMENT<br>\n  };<br>\n};</p>\n\n\n\n<p>export const decrementAction = () =&gt; {<br>\n  return {<br>\n    type: DECREMENT<br>\n  };<br>\n};</p>\n\n\n\n<p>export const resetAction = () =&gt; {<br>\n  return {<br>\n    type: RESET<br>\n  };<br>\n};</p>\n\n\n\n<p>export default counterReducer;</p>\n\n\n\n<p>Agora vamos criar nossos custom hooks, o primeiro é o useCombinedReducers, responsável por retornar um array com os reducers e um objeto com o valor padrão da nossa store. Aqui iremos utilizar o hook useReducer.</p>\n\n\n\n<p>//src/store/hooks/useCombinedReducers.js<br>\nimport { useReducer } from &#8220;react&#8221;;<br>\nimport counterReducer, { counterDefault } from &#8220;./../reducers/counter&#8221;;<br>\nimport authReducer, { authDefault } from &#8220;./../reducers/auth&#8221;;</p>\n\n\n\n<p>const useCombinedReducers = () =&gt; {<br>\n  const [counterStore, counter] = useReducer(counterReducer, counterDefault);<br>\n  const [authStore, auth] = useReducer(authReducer, authDefault);</p>\n\n\n\n<p>return {<br>\n    store: { …counterStore, …authStore },<br>\n    reducers: [counter, auth]<br>\n  };<br>\n};</p>\n\n\n\n<p>export default useCombinedReducers;</p>\n\n\n\n<p>Sempre que formos adicionar um novo objeto na nossa store, precisaremos apenas alterar esse arquivo, importando seu reducer, seu valor padrão, passa-los para o useReducer e os retornar na função principal.</p>\n\n\n\n<p>Essa foi a única alteração que eu fiz pro Redux, para tornar nosso componente Provider mais dinâmico e não precisar altera-lo novamente.</p>\n\n\n\n<p>Nosso segundo custom hook é o useStore, responsável por criar e fornecer o context da aplicação através do hook useContext.</p>\n\n\n\n<p>//src/store/hooks/useStore.js<br>\nimport { useContext, createContext } from &#8220;react&#8221;;<br>\nimport { authDefault } from &#8220;../reducers/auth&#8221;;<br>\nimport { counterDefault } from &#8220;../reducers/counter&#8221;;</p>\n\n\n\n<p>export const defaultStore = {<br>\n  store: { …authDefault, …counterDefault },<br>\n  dispatch: () =&gt; {}<br>\n};</p>\n\n\n\n<p>export const StoreContext = createContext(defaultStore);<br>\nexport default () =&gt; {<br>\n  return useContext(storeContext);<br>\n};</p>\n\n\n\n<p>Com esse custom hook também será possível acessar diretamente nossa store e o dispatch, além do componente Connect, que vamos criar logo em seguida.</p>\n\n\n\n<p>O Connect injetará nossa store e dispatch nos nossos componentes. Aqui usamos componente StoreContext retornado no nosso hook useStore.</p>\n\n\n\n<p>//src/store/connect.js<br>\nimport React from &#8220;react&#8221;;<br>\nimport { StoreContext } from &#8220;./hooks/useStore&#8221;;</p>\n\n\n\n<p>const returnPropsAsDefault = (store, props) =&gt; props;</p>\n\n\n\n<p>const Connect = (mapStateToProps = returnPropsAsDefault) =&gt; Component =&gt; {<br>\n  return function WrapConnect(props) {<br>\n    return (<br>\n      \n        {({ dispatch, store }) =&gt; {\n          const storeProps = mapStateToProps(store, props);\n          return ;\n        }}\n      <br>\n    );<br>\n  };<br>\n};</p>\n\n\n\n<p>export default Connect;</p>\n\n\n\n<p>Ele funcionará semelhante ao do Redux, recebendo o mapStateToProps e o componente que receberá a store.</p>\n\n\n\n<p>Lembrando que o mapStateToProps é uma função que recebe a store e as props originais. Você é responsável por retornar a store inteira ou selecionar os objetos que precise, assim:</p>\n\n\n\n<p>function mapStateToProps(store, props) {<br>\n  return {<br>\n    …store,<br>\n    …props<br>\n  }<br>\n}</p>\n\n\n\n<p>export default Connect(mapStateToProps)(Component)</p>\n\n\n\n<p>Caso o mapStateToProps não seja fornecido, sua função padrão returnPropsAsDefault retornará as props originais do componente.</p>\n\n\n\n<p>O próximo componente será nosso Provider, que irá envolver nossa plataforma e tornar nossa store disponível dentro dela. Usamos o hook useCombinedReducers para receber o valor da store e um array com nossos reducers.</p>\n\n\n\n<p>//src/store/index.js<br>\nimport React from &#8220;react&#8221;;<br>\nimport PropTypes from &#8220;prop-types&#8221;;<br>\nimport useCombinedReducers from &#8220;./hooks/useCombinedReducers&#8221;;<br>\nimport { StoreContext } from &#8220;./hooks/useStore&#8221;;</p>\n\n\n\n<p>const Provider = ({ children }) =&gt; {<br>\n  const { store, reducers } = useCombinedReducers();</p>\n\n\n\n<p>const triggerDispatchs = action =&gt; {<br>\n    for (let i = 0; i &lt; reducers.length; i++) {<br>\n      reducers<a href=\"action\">i</a>;<br>\n    }<br>\n  };</p>\n\n\n\n<p>return (<br>\n    \n      {children}\n    <br>\n  );<br>\n};</p>\n\n\n\n<p>Provider.propTypes = {<br>\n  children: PropTypes.node.isRequired<br>\n};</p>\n\n\n\n<p>export default Provider;</p>\n\n\n\n<p>Apenas explicando, o método triggerDispatchs faz um loop em nossos reducers, passando a action como parâmetro pra cada um deles.</p>\n\n\n\n<p>Também podemos adicionar um middleware nesse arquivo, que servirá pra interceptar nossos dispatchs e fazer qualquer coisa que queremos a partir disso, como uma requisição, disparar outra action, etc.</p>\n\n\n\n<p>Ele será basicamente assim.</p>\n\n\n\n<p>//src/store/middleware.js<br>\nimport { LOGOUT } from &#8220;./reducers/auth&#8221;;<br>\nimport { resetAction } from &#8220;./reducers/counter&#8221;;</p>\n\n\n\n<p>export default action =&gt; dispatch =&gt; {<br>\n  if (action.type === LOGOUT) {<br>\n    dispatch(resetAction());<br>\n  }</p>\n\n\n\n<p>dispatch(action);<br>\n};</p>\n\n\n\n<p>Ele é um closure que recebe a action e o dispatch, nesse caso estou disparando a action resetAction caso o type da action original seja LOGOUT.</p>\n\n\n\n<p>Pra o utilizarmos precisamos alterar o arquivo do nosso Provider, importando nosso middleware, criando o método withMiddleware e substituir a atribuição do dispatch.</p>\n\n\n\n<p>//src/store/index.js<br>\nimport React from &#8220;react&#8221;;<br>\nimport PropTypes from &#8220;prop-types&#8221;;<br>\nimport useCombinedReducers from &#8220;./hooks/useCombinedReducers&#8221;;<br>\nimport { StoreContext } from &#8220;./hooks/useStore&#8221;;<br>\nimport middleware from &#8220;./middleware&#8221;;</p>\n\n\n\n<p>const Provider = ({ children }) =&gt; {<br>\n  const { store, reducers } = useCombinedReducers();</p>\n\n\n\n<p>const triggerDispatchs = action =&gt; {<br>\n    for (let i = 0; i &lt; reducers.length; i++) {<br>\n      reducers<a href=\"action\">i</a>;<br>\n    }<br>\n  };</p>\n\n\n\n<p>const withMiddleware = action =&gt; {<br>\n    middleware(action)(triggerDispatchs);<br>\n  };</p>\n\n\n\n<p>return (<br>\n    \n      {children}\n    <br>\n  );<br>\n};</p>\n\n\n\n<p>Provider.propTypes = {<br>\n  children: PropTypes.node.isRequired<br>\n};</p>\n\n\n\n<p>export default Provider;</p>\n\n\n\n<p>Agora só precisamos envolver nossa aplicação com o Provider, dessa maneira.</p>\n\n\n\n<p>//src/index.js<br>\nimport React from &#8220;react&#8221;;<br>\nimport ReactDOM from &#8220;react-dom&#8221;;<br>\nimport &#8220;./index.css&#8221;;<br>\nimport App from &#8220;./App&#8221;;<br>\nimport Provider from &#8220;./store&#8221;;</p>\n\n\n\n<p>ReactDOM.render(<br>\n  \n    \n  ,<br>\n  document.getElementById(&#8220;root&#8221;)<br>\n);</p>\n\n\n\n<p>Nesse ponto já temos tudo o que precisamos configurado para usar a store na nossa aplicação.<br>\nConectando nossos componentes</p>\n\n\n\n<p>Vamos começar conectando nossa store nos nossos componentes Counter, Login e Header.</p>\n\n\n\n<p>//src/container/counter.js<br>\nimport React from &#8220;react&#8221;;<br>\nimport PropTypes from &#8220;prop-types&#8221;;<br>\nimport ConnectTo from &#8220;../store/connect&#8221;;<br>\nimport { decrementAction, incrementAction } from &#8220;../store/reducers/counter&#8221;;</p>\n\n\n\n<p>const Counter = ({ dispatch, counter }) =&gt; {<br>\n  const decrementHandler = () =&gt; dispatch(decrementAction());<br>\n  const incrementHandler = () =&gt; dispatch(incrementAction());</p>\n\n\n\n<p>return (<br>\n    </p>\n\n\n\n<p>{counter}\n      \n        \n          &#8211;\n        \n        \n          +\n        \n      <br><br>\n  );<br>\n};\n</p>\n\n\n\n<p>Counter.propTypes = {<br>\n  dispatch: PropTypes.func.isRequired,<br>\n  counter: PropTypes.number.isRequired<br>\n};</p>\n\n\n\n<p>const mapStateToProps = ({ counter }, props) =&gt; {<br>\n  return {<br>\n    counter,<br>\n    …props<br>\n  };<br>\n};</p>\n\n\n\n<p>export default ConnectTo(mapStateToProps)(Counter);</p>\n\n\n\n<p>//src/container/login.js<br>\nimport React, { useState } from &#8220;react&#8221;;<br>\nimport PropTypes from &#8220;prop-types&#8221;;<br>\nimport Connect from &#8220;../store/connect&#8221;;<br>\nimport { loginAction } from &#8220;../store/reducers/auth&#8221;;</p>\n\n\n\n<p>const Login = ({ dispatch }) =&gt; {<br>\n  const [name, setName] = useState(&#8220;&#8221;);<br>\n  const changeNameHandler = ({ target: { value } }) =&gt; setName(value);<br>\n  const onSubmitHandler = () =&gt; dispatch(loginAction(name));<br>\n  return (<br>\n    </p>\n\n\n\n<p>\n          Context + useState ={&#8221; &#8220;}\n          \n            ❤️\n          \n        \n        \n        \n          Entrar\n        \n      \n    <br>\n  );<br>\n};\n</p>\n\n\n\n<p>Login.propTypes = {<br>\n  dispatch: PropTypes.func.isRequired<br>\n};</p>\n\n\n\n<p>export default Connect()(Login);</p>\n\n\n\n<p>//src/container/header.js<br>\nimport React from &#8220;react&#8221;;<br>\nimport { logoutAction } from &#8220;../store/reducers/auth&#8221;;<br>\nimport useStore from &#8220;../store/hooks/useStore&#8221;;</p>\n\n\n\n<p>const Header = () =&gt; {<br>\n  const {<br>\n    dispatch,<br>\n    store: { auth }<br>\n  } = useStore();<br>\n  const logoutHandler = () =&gt; dispatch(logoutAction());<br>\n  return (<br>\n    </p>\n\n\n\n<p>\n            Context + useState ={&#8221; &#8220;}\n            \n              ❤️\n            \n          </p>\n\n\n\n<p>Olá, {auth.user}\n            \n              Sair\n            \n          <br><br><br><br>\n  );<br>\n};\n</p>\n\n\n\n<p>export default Header;</p>\n\n\n\n<p>Se você já usou Redux, deve ser familiar com o que temos aqui; o componente Connect injeta o dispatch e a store, também importamos as actions pra passarmos como seu parâmetro.</p>\n\n\n\n<p>No nosso Header eu estou usando o custom hook useStore pra acessar a store e o dispatch, ao invés do Connect. Fique a vontade pra usar qual preferir 🙂</p>\n\n\n\n<p>Agora vamos colocar todos nossos componentes juntos e criar uma condição pra mostra-los, usando a autenticação da nossa store.</p>\n\n\n\n<p>//src/app.js<br>\nimport React from &#8220;react&#8221;;<br>\nimport PropTypes from &#8220;prop-types&#8221;;<br>\nimport Counter from &#8220;./container/counter&#8221;;<br>\nimport Login from &#8220;./container/login&#8221;;<br>\nimport Connect from &#8220;./store/connect&#8221;;<br>\nimport Header from &#8220;./container/header&#8221;;</p>\n\n\n\n<p>const App = ({ auth }) =&gt; {<br>\n  return (<br>\n    \n      \n        {auth.isLogged ? (\n          &lt;&gt;\n            \n            \n          \n        ) : (\n          \n        )}\n      <br><br>\n  );<br>\n};\n</p>\n\n\n\n<p>App.propTypes = {<br>\n  auth: PropTypes.shape({<br>\n    isLogged: PropTypes.bool<br>\n  }).isRequired<br>\n};</p>\n\n\n\n<p>const mapStateToProps = ({ auth }, props) =&gt; {<br>\n  return {<br>\n    auth,<br>\n    …props<br>\n  };<br>\n};</p>\n\n\n\n<p>export default Connect(mapStateToProps)(App);</p>\n\n\n\n<p>É isso. Sua aplicação já deve estar funcionando com uma store criada com os hooks nativos do React.</p>\n\n\n\n<p>Você pode ver a demo de como ficou aqui.</p>\n\n\n\n<p>Ressaltando que os dois únicos pontos negativos comparados ao Redux é a falta de uma extensão do navegador, como o Redux DevTools, que nos permite debugar as interações com a store e também a falta de suporte para as actions assíncronas, como redux-thunk.</p>\n\n\n\n<p>Também preciso dizer que dependendo do tamanho e complexidade da sua aplicação, usar o Redux poderá ser mais perfomatico do que os hooks.</p>\n\n\n\n<p>Espero que não fique decepcionado comigo por causa desses pontos.</p>\n\n\n\n<p>Todo esse exemplo está nesse repositório, fique a vontade pra baixa-lo, usa-lo, compartilha-lo e deixar uma star.</p>\n\n\n\n<p>Qualquer sugestão, crítica ou comentário é super bem vindo, compartilhe comigo nos comentários a baixo.</p>\n\n\n\n<p>Até breve.</p>\n","excerpt":"<p>In 2019 I was learning how to use React Hooks and decided to replace the state management from a simple application that I was building of Redux to React Hooks. I didn&#8217;t know how I would do that, however, in the end, it worked pretty well. I kept the concerns of reducer, actions, types, middleware, [&hellip;]</p>\n","date":"01-30-2020","featured_media":{"localFile":{"childImageSharp":{"resolutions":{"src":"/static/6ab18a3b7fdbd04ff6f656cafc14414d/48cea/road-4598095_1280.jpg"}}}},"acf":{"translation":"/substituindo-redux-por-hooks"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"9e0c43b8-c34b-5348-9a7b-e01b8f62d6b8","ola":true}}}