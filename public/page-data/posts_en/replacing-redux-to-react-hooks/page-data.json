{"componentChunkName":"component---src-templates-post-en-js","path":"/posts_en/replacing-redux-to-react-hooks/","result":{"data":{"wordpressWpPostsEn":{"id":"9e0c43b8-c34b-5348-9a7b-e01b8f62d6b8","title":"Replacing Redux to React Hooks","content":"\n<p>In 2019 I was learning how to use React Hooks and decided to replace the state management from a simple application that I was building of Redux to React Hooks. I didn&#8217;t know how I would do that, however, in the end, it worked pretty well.</p>\n\n\n\n<p>I kept the concerns of reducer, actions, types, middleware, mapStateToProps and I wrote an article on Medium showing up how I had made. After I shared within the community, it was even published at React Brazil&#8217;s Oficial Account on Medium.</p>\n\n\n\n<p>I was really happy with the feedback but I felt I could refactor that code which I wrote one year ago and make it clean, organized, therefore, I ended up rewriting my code example and my article, that became this that you&#8217;re reading right now. </p>\n\n\n\n<p>I&#8217;m using the same example of a simple counter and authentication. In case you want, you can check the demo and the repository with the final code.</p>\n\n\n\n<p>Primeiro, vamos criar os estados do nosso contador e autentica√ß√£o na nossa store e tamb√©m seus reducers, types e actions. Eles seguem basicamente o mesmo modelo do Redux, estou apenas usando o padr√£o Ducks pra manter tudo o que √© relacionado no mesmo arquivo.</p>\n\n\n\n<p>Voc√™ pode ler mais sobre esse padr√£o de organiza√ß√£o nesse link.</p>\n\n\n\n<p>//src/store/reducers/auth.js<br>\nexport const authDefault = {<br>\n  auth: {<br>\n    isLogged: false,<br>\n    user: {}<br>\n  }<br>\n};</p>\n\n\n\n<p>export const LOGIN = &#8220;LOGIN&#8221;;<br>\nexport const LOGOUT = &#8220;LOGOUT&#8221;;</p>\n\n\n\n<p>const authReducer = (state = authDefault, action) =&gt; {<br>\n  switch (action.type) {<br>\n    case LOGIN:<br>\n      return {<br>\n        auth: {<br>\n          ‚Ä¶state.auth,<br>\n          isLogged: true,<br>\n          user: action.payload<br>\n        }<br>\n      };<br>\n    case LOGOUT:<br>\n      return {<br>\n        auth: {<br>\n          ‚Ä¶state.auth,<br>\n          isLogged: false,<br>\n          user: {}<br>\n        }<br>\n      };<br>\n    default:<br>\n      return state;<br>\n  }<br>\n};</p>\n\n\n\n<p>export const loginAction = user =&gt; {<br>\n  return {<br>\n    type: LOGIN,<br>\n    payload: user<br>\n  };<br>\n};</p>\n\n\n\n<p>export const logoutAction = () =&gt; {<br>\n  return {<br>\n    type: LOGOUT<br>\n  };<br>\n};</p>\n\n\n\n<p>export default authReducer;</p>\n\n\n\n<p>//src/store/reducers/counter.js<br>\nexport const counterDefault = {<br>\n  counter: 0<br>\n};</p>\n\n\n\n<p>export const INCREMENT = &#8220;INCREMENT&#8221;;<br>\nexport const DECREMENT = &#8220;DECREMENT&#8221;;<br>\nexport const RESET = &#8220;RESET&#8221;;</p>\n\n\n\n<p>const counterReducer = (state = counterDefault, action) =&gt; {<br>\n  switch (action.type) {<br>\n    case INCREMENT:<br>\n      return {<br>\n        ‚Ä¶state,<br>\n        counter: state.counter + 1<br>\n      };<br>\n    case DECREMENT:<br>\n      return {<br>\n        ‚Ä¶state,<br>\n        counter: state.counter &#8211; 1<br>\n      };<br>\n    case RESET:<br>\n      return {<br>\n        counter: 0<br>\n      };<br>\n    default:<br>\n      return state;<br>\n  }<br>\n};</p>\n\n\n\n<p>export const incrementAction = () =&gt; {<br>\n  return {<br>\n    type: INCREMENT<br>\n  };<br>\n};</p>\n\n\n\n<p>export const decrementAction = () =&gt; {<br>\n  return {<br>\n    type: DECREMENT<br>\n  };<br>\n};</p>\n\n\n\n<p>export const resetAction = () =&gt; {<br>\n  return {<br>\n    type: RESET<br>\n  };<br>\n};</p>\n\n\n\n<p>export default counterReducer;</p>\n\n\n\n<p>Agora vamos criar nossos custom hooks, o primeiro √© o useCombinedReducers, respons√°vel por retornar um array com os reducers e um objeto com o valor padr√£o da nossa store. Aqui iremos utilizar o hook useReducer.</p>\n\n\n\n<p>//src/store/hooks/useCombinedReducers.js<br>\nimport { useReducer } from &#8220;react&#8221;;<br>\nimport counterReducer, { counterDefault } from &#8220;./../reducers/counter&#8221;;<br>\nimport authReducer, { authDefault } from &#8220;./../reducers/auth&#8221;;</p>\n\n\n\n<p>const useCombinedReducers = () =&gt; {<br>\n  const [counterStore, counter] = useReducer(counterReducer, counterDefault);<br>\n  const [authStore, auth] = useReducer(authReducer, authDefault);</p>\n\n\n\n<p>return {<br>\n    store: { ‚Ä¶counterStore, ‚Ä¶authStore },<br>\n    reducers: [counter, auth]<br>\n  };<br>\n};</p>\n\n\n\n<p>export default useCombinedReducers;</p>\n\n\n\n<p>Sempre que formos adicionar um novo objeto na nossa store, precisaremos apenas alterar esse arquivo, importando seu reducer, seu valor padr√£o, passa-los para o useReducer e os retornar na fun√ß√£o principal.</p>\n\n\n\n<p>Essa foi a √∫nica altera√ß√£o que eu fiz pro Redux, para tornar nosso componente Provider mais din√¢mico e n√£o precisar altera-lo novamente.</p>\n\n\n\n<p>Nosso segundo custom hook √© o useStore, respons√°vel por criar e fornecer o context da aplica√ß√£o atrav√©s do hook useContext.</p>\n\n\n\n<p>//src/store/hooks/useStore.js<br>\nimport { useContext, createContext } from &#8220;react&#8221;;<br>\nimport { authDefault } from &#8220;../reducers/auth&#8221;;<br>\nimport { counterDefault } from &#8220;../reducers/counter&#8221;;</p>\n\n\n\n<p>export const defaultStore = {<br>\n  store: { ‚Ä¶authDefault, ‚Ä¶counterDefault },<br>\n  dispatch: () =&gt; {}<br>\n};</p>\n\n\n\n<p>export const StoreContext = createContext(defaultStore);<br>\nexport default () =&gt; {<br>\n  return useContext(storeContext);<br>\n};</p>\n\n\n\n<p>Com esse custom hook tamb√©m ser√° poss√≠vel acessar diretamente nossa store e o dispatch, al√©m do componente Connect, que vamos criar logo em seguida.</p>\n\n\n\n<p>O Connect injetar√° nossa store e dispatch nos nossos componentes. Aqui usamos componente StoreContext retornado no nosso hook useStore.</p>\n\n\n\n<p>//src/store/connect.js<br>\nimport React from &#8220;react&#8221;;<br>\nimport { StoreContext } from &#8220;./hooks/useStore&#8221;;</p>\n\n\n\n<p>const returnPropsAsDefault = (store, props) =&gt; props;</p>\n\n\n\n<p>const Connect = (mapStateToProps = returnPropsAsDefault) =&gt; Component =&gt; {<br>\n  return function WrapConnect(props) {<br>\n    return (<br>\n      \n        {({ dispatch, store }) =&gt; {\n          const storeProps = mapStateToProps(store, props);\n          return ;\n        }}\n      <br>\n    );<br>\n  };<br>\n};</p>\n\n\n\n<p>export default Connect;</p>\n\n\n\n<p>Ele funcionar√° semelhante ao do Redux, recebendo o mapStateToProps e o componente que receber√° a store.</p>\n\n\n\n<p>Lembrando que o mapStateToProps √© uma fun√ß√£o que recebe a store e as props originais. Voc√™ √© respons√°vel por retornar a store inteira ou selecionar os objetos que precise, assim:</p>\n\n\n\n<p>function mapStateToProps(store, props) {<br>\n  return {<br>\n    ‚Ä¶store,<br>\n    ‚Ä¶props<br>\n  }<br>\n}</p>\n\n\n\n<p>export default Connect(mapStateToProps)(Component)</p>\n\n\n\n<p>Caso o mapStateToProps n√£o seja fornecido, sua fun√ß√£o padr√£o returnPropsAsDefault retornar√° as props originais do componente.</p>\n\n\n\n<p>O pr√≥ximo componente ser√° nosso Provider, que ir√° envolver nossa plataforma e tornar nossa store dispon√≠vel dentro dela. Usamos o hook useCombinedReducers para receber o valor da store e um array com nossos reducers.</p>\n\n\n\n<p>//src/store/index.js<br>\nimport React from &#8220;react&#8221;;<br>\nimport PropTypes from &#8220;prop-types&#8221;;<br>\nimport useCombinedReducers from &#8220;./hooks/useCombinedReducers&#8221;;<br>\nimport { StoreContext } from &#8220;./hooks/useStore&#8221;;</p>\n\n\n\n<p>const Provider = ({ children }) =&gt; {<br>\n  const { store, reducers } = useCombinedReducers();</p>\n\n\n\n<p>const triggerDispatchs = action =&gt; {<br>\n    for (let i = 0; i &lt; reducers.length; i++) {<br>\n      reducers<a href=\"action\">i</a>;<br>\n    }<br>\n  };</p>\n\n\n\n<p>return (<br>\n    \n      {children}\n    <br>\n  );<br>\n};</p>\n\n\n\n<p>Provider.propTypes = {<br>\n  children: PropTypes.node.isRequired<br>\n};</p>\n\n\n\n<p>export default Provider;</p>\n\n\n\n<p>Apenas explicando, o m√©todo triggerDispatchs faz um loop em nossos reducers, passando a action como par√¢metro pra cada um deles.</p>\n\n\n\n<p>Tamb√©m podemos adicionar um middleware nesse arquivo, que servir√° pra interceptar nossos dispatchs e fazer qualquer coisa que queremos a partir disso, como uma requisi√ß√£o, disparar outra action, etc.</p>\n\n\n\n<p>Ele ser√° basicamente assim.</p>\n\n\n\n<p>//src/store/middleware.js<br>\nimport { LOGOUT } from &#8220;./reducers/auth&#8221;;<br>\nimport { resetAction } from &#8220;./reducers/counter&#8221;;</p>\n\n\n\n<p>export default action =&gt; dispatch =&gt; {<br>\n  if (action.type === LOGOUT) {<br>\n    dispatch(resetAction());<br>\n  }</p>\n\n\n\n<p>dispatch(action);<br>\n};</p>\n\n\n\n<p>Ele √© um closure que recebe a action e o dispatch, nesse caso estou disparando a action resetAction caso o type da action original seja LOGOUT.</p>\n\n\n\n<p>Pra o utilizarmos precisamos alterar o arquivo do nosso Provider, importando nosso middleware, criando o m√©todo withMiddleware e substituir a atribui√ß√£o do dispatch.</p>\n\n\n\n<p>//src/store/index.js<br>\nimport React from &#8220;react&#8221;;<br>\nimport PropTypes from &#8220;prop-types&#8221;;<br>\nimport useCombinedReducers from &#8220;./hooks/useCombinedReducers&#8221;;<br>\nimport { StoreContext } from &#8220;./hooks/useStore&#8221;;<br>\nimport middleware from &#8220;./middleware&#8221;;</p>\n\n\n\n<p>const Provider = ({ children }) =&gt; {<br>\n  const { store, reducers } = useCombinedReducers();</p>\n\n\n\n<p>const triggerDispatchs = action =&gt; {<br>\n    for (let i = 0; i &lt; reducers.length; i++) {<br>\n      reducers<a href=\"action\">i</a>;<br>\n    }<br>\n  };</p>\n\n\n\n<p>const withMiddleware = action =&gt; {<br>\n    middleware(action)(triggerDispatchs);<br>\n  };</p>\n\n\n\n<p>return (<br>\n    \n      {children}\n    <br>\n  );<br>\n};</p>\n\n\n\n<p>Provider.propTypes = {<br>\n  children: PropTypes.node.isRequired<br>\n};</p>\n\n\n\n<p>export default Provider;</p>\n\n\n\n<p>Agora s√≥ precisamos envolver nossa aplica√ß√£o com o Provider, dessa maneira.</p>\n\n\n\n<p>//src/index.js<br>\nimport React from &#8220;react&#8221;;<br>\nimport ReactDOM from &#8220;react-dom&#8221;;<br>\nimport &#8220;./index.css&#8221;;<br>\nimport App from &#8220;./App&#8221;;<br>\nimport Provider from &#8220;./store&#8221;;</p>\n\n\n\n<p>ReactDOM.render(<br>\n  \n    \n  ,<br>\n  document.getElementById(&#8220;root&#8221;)<br>\n);</p>\n\n\n\n<p>Nesse ponto j√° temos tudo o que precisamos configurado para usar a store na nossa aplica√ß√£o.<br>\nConectando nossos componentes</p>\n\n\n\n<p>Vamos come√ßar conectando nossa store nos nossos componentes Counter, Login e Header.</p>\n\n\n\n<p>//src/container/counter.js<br>\nimport React from &#8220;react&#8221;;<br>\nimport PropTypes from &#8220;prop-types&#8221;;<br>\nimport ConnectTo from &#8220;../store/connect&#8221;;<br>\nimport { decrementAction, incrementAction } from &#8220;../store/reducers/counter&#8221;;</p>\n\n\n\n<p>const Counter = ({ dispatch, counter }) =&gt; {<br>\n  const decrementHandler = () =&gt; dispatch(decrementAction());<br>\n  const incrementHandler = () =&gt; dispatch(incrementAction());</p>\n\n\n\n<p>return (<br>\n    </p>\n\n\n\n<p>{counter}\n      \n        \n          &#8211;\n        \n        \n          +\n        \n      <br><br>\n  );<br>\n};\n</p>\n\n\n\n<p>Counter.propTypes = {<br>\n  dispatch: PropTypes.func.isRequired,<br>\n  counter: PropTypes.number.isRequired<br>\n};</p>\n\n\n\n<p>const mapStateToProps = ({ counter }, props) =&gt; {<br>\n  return {<br>\n    counter,<br>\n    ‚Ä¶props<br>\n  };<br>\n};</p>\n\n\n\n<p>export default ConnectTo(mapStateToProps)(Counter);</p>\n\n\n\n<p>//src/container/login.js<br>\nimport React, { useState } from &#8220;react&#8221;;<br>\nimport PropTypes from &#8220;prop-types&#8221;;<br>\nimport Connect from &#8220;../store/connect&#8221;;<br>\nimport { loginAction } from &#8220;../store/reducers/auth&#8221;;</p>\n\n\n\n<p>const Login = ({ dispatch }) =&gt; {<br>\n  const [name, setName] = useState(&#8220;&#8221;);<br>\n  const changeNameHandler = ({ target: { value } }) =&gt; setName(value);<br>\n  const onSubmitHandler = () =&gt; dispatch(loginAction(name));<br>\n  return (<br>\n    </p>\n\n\n\n<p>\n          Context + useState ={&#8221; &#8220;}\n          \n            ‚ù§Ô∏è\n          \n        \n        \n        \n          Entrar\n        \n      \n    <br>\n  );<br>\n};\n</p>\n\n\n\n<p>Login.propTypes = {<br>\n  dispatch: PropTypes.func.isRequired<br>\n};</p>\n\n\n\n<p>export default Connect()(Login);</p>\n\n\n\n<p>//src/container/header.js<br>\nimport React from &#8220;react&#8221;;<br>\nimport { logoutAction } from &#8220;../store/reducers/auth&#8221;;<br>\nimport useStore from &#8220;../store/hooks/useStore&#8221;;</p>\n\n\n\n<p>const Header = () =&gt; {<br>\n  const {<br>\n    dispatch,<br>\n    store: { auth }<br>\n  } = useStore();<br>\n  const logoutHandler = () =&gt; dispatch(logoutAction());<br>\n  return (<br>\n    </p>\n\n\n\n<p>\n            Context + useState ={&#8221; &#8220;}\n            \n              ‚ù§Ô∏è\n            \n          </p>\n\n\n\n<p>Ol√°, {auth.user}\n            \n              Sair\n            \n          <br><br><br><br>\n  );<br>\n};\n</p>\n\n\n\n<p>export default Header;</p>\n\n\n\n<p>Se voc√™ j√° usou Redux, deve ser familiar com o que temos aqui; o componente Connect injeta o dispatch e a store, tamb√©m importamos as actions pra passarmos como seu par√¢metro.</p>\n\n\n\n<p>No nosso Header eu estou usando o custom hook useStore pra acessar a store e o dispatch, ao inv√©s do Connect. Fique a vontade pra usar qual preferir üôÇ</p>\n\n\n\n<p>Agora vamos colocar todos nossos componentes juntos e criar uma condi√ß√£o pra mostra-los, usando a autentica√ß√£o da nossa store.</p>\n\n\n\n<p>//src/app.js<br>\nimport React from &#8220;react&#8221;;<br>\nimport PropTypes from &#8220;prop-types&#8221;;<br>\nimport Counter from &#8220;./container/counter&#8221;;<br>\nimport Login from &#8220;./container/login&#8221;;<br>\nimport Connect from &#8220;./store/connect&#8221;;<br>\nimport Header from &#8220;./container/header&#8221;;</p>\n\n\n\n<p>const App = ({ auth }) =&gt; {<br>\n  return (<br>\n    \n      \n        {auth.isLogged ? (\n          &lt;&gt;\n            \n            \n          \n        ) : (\n          \n        )}\n      <br><br>\n  );<br>\n};\n</p>\n\n\n\n<p>App.propTypes = {<br>\n  auth: PropTypes.shape({<br>\n    isLogged: PropTypes.bool<br>\n  }).isRequired<br>\n};</p>\n\n\n\n<p>const mapStateToProps = ({ auth }, props) =&gt; {<br>\n  return {<br>\n    auth,<br>\n    ‚Ä¶props<br>\n  };<br>\n};</p>\n\n\n\n<p>export default Connect(mapStateToProps)(App);</p>\n\n\n\n<p>√â isso. Sua aplica√ß√£o j√° deve estar funcionando com uma store criada com os hooks nativos do React.</p>\n\n\n\n<p>Voc√™ pode ver a demo de como ficou aqui.</p>\n\n\n\n<p>Ressaltando que os dois √∫nicos pontos negativos comparados ao Redux √© a falta de uma extens√£o do navegador, como o Redux DevTools, que nos permite debugar as intera√ß√µes com a store e tamb√©m a falta de suporte para as actions ass√≠ncronas, como redux-thunk.</p>\n\n\n\n<p>Tamb√©m preciso dizer que dependendo do tamanho e complexidade da sua aplica√ß√£o, usar o Redux poder√° ser mais perfomatico do que os hooks.</p>\n\n\n\n<p>Espero que n√£o fique decepcionado comigo por causa desses pontos.</p>\n\n\n\n<p>Todo esse exemplo est√° nesse reposit√≥rio, fique a vontade pra baixa-lo, usa-lo, compartilha-lo e deixar uma star.</p>\n\n\n\n<p>Qualquer sugest√£o, cr√≠tica ou coment√°rio √© super bem vindo, compartilhe comigo nos coment√°rios a baixo.</p>\n\n\n\n<p>At√© breve.</p>\n","excerpt":"<p>In 2019 I was learning how to use React Hooks and decided to replace the state management from a simple application that I was building of Redux to React Hooks. I didn&#8217;t know how I would do that, however, in the end, it worked pretty well. I kept the concerns of reducer, actions, types, middleware, [&hellip;]</p>\n","date":"01-30-2020","featured_media":{"localFile":{"childImageSharp":{"resolutions":{"src":"/static/6ab18a3b7fdbd04ff6f656cafc14414d/48cea/road-4598095_1280.jpg"}}}},"acf":{"translation":"/substituindo-redux-por-hooks"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"9e0c43b8-c34b-5348-9a7b-e01b8f62d6b8","ola":true}}}